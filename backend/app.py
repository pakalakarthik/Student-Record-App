from flask import Flask, request, jsonify
import sqlite3
from flask_cors import CORS





# Create the Flask application object. __name__ tells Flask where to look
# for templates and static files; it's the module name of the current file.
app = Flask(__name__)
CORS(app)


# Helper to open a database connection. We keep this in one function so
# all endpoints open the DB consistently and we can change settings here.
def get_db_connection():
    # Open (or create) the SQLite database file named students.db
    conn = sqlite3.connect("students.db")
    # Enable WAL mode so concurrent reads/writes work better
    conn.execute("PRAGMA journal_mode=WAL;")
    # Make fetched rows behave like dictionaries (access by column name)
    conn.row_factory = sqlite3.Row
    # Return the connection object to the caller
    return conn


# Route for the root path. Visiting http://127.0.0.1:5000/ will call this.
@app.route("/")
def home():
    # Return a simple text response confirming the API is running
    return "Student API is running!"


# -------- READ All Students --------
# Handle GET requests to /students and return all student records
@app.route("/students", methods=["GET"])
def get_students():
    # Open DB connection using helper
    conn = get_db_connection()
    # Create a cursor to execute SQL queries
    cur = conn.cursor()
    # Run SQL to select all rows from the students table
    cur.execute("SELECT * FROM students")
    # Fetch all rows returned by the query
    rows = cur.fetchall()
    # Close the connection promptly to free the DB for other operations
    conn.close()
    # Debug print (not required) â€” removed or kept for learning purposes
    print("student added")
    # Convert each sqlite Row into a plain dict so it can be JSON-encoded
    students = [dict(row) for row in rows]
    # Return the list of students as JSON response
    return jsonify(students)


# -------- CREATE Student --------
# Handle POST requests to /students to insert a new student record
@app.route("/students", methods=["POST"])
def add_student():
    # Parse the JSON body of the request into a Python dict
    data = request.get_json()

    # Extract expected fields from the JSON payload
    name = data["name"]
    age = data["age"]
    grade = data["grade"]
    email = data["email"]

    # Open DB, insert the new row, and commit the transaction
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute(
        "INSERT INTO students (name, age, grade, email) VALUES (?, ?, ?, ?)",
        (name, age, grade, email)
    )
    # Save the change to disk
    conn.commit()
    # Get the id autogenerated by SQLite for the new row
    new_id = cur.lastrowid
    # Close the connection
    conn.close()

    # Return a JSON response with a success message and the new record id
    return jsonify({"message": "Student added", "id": new_id})


# -------- UPDATE Student --------
# Handle PUT requests to /students/<id> to update an existing student
@app.route("/students/<int:id>", methods=["PUT"])
def update_student(id):
    # Parse JSON body with updated fields
    data = request.get_json()

    # Open DB and execute an UPDATE statement with placeholders
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute("""
        UPDATE students 
        SET name = ?, age = ?, grade = ?, email = ?
        WHERE id = ?
    """, (data["name"], data["age"], data["grade"], data["email"], id))
    # Commit the change
    conn.commit()
    # Close connection
    conn.close()

    # Return confirmation
    return jsonify({"message": "Student updated"})


# -------- DELETE Student --------
# Handle DELETE requests to /students/<id> to remove a student record
@app.route("/students/<int:id>", methods=["DELETE"])
def delete_student(id):
    # Open DB, execute DELETE for the given id, commit and close
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute("DELETE FROM students WHERE id = ?", (id,))
    conn.commit()
    conn.close()

    # Return a success message as JSON
    return jsonify({"message": "Student deleted"})


# When this file is run directly, start Flask's development server
if __name__ == "__main__":
    # debug=True enables auto-reload and a helpful debugger on errors
    app.run(debug=True)
